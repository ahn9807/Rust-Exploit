#![feature(vec_into_raw_parts)]
#![feature(asm)]

fn main() {
    unsafe {
        println!("{}", rdpkru());
    }
}

#[cfg(test)]
mod tests {
    #[test]
    #[should_panic]
    fn buffer_overflow() {
        let mut malicious_vec = vec![0usize; 10];
        let trust_vec = vec![0usize; 10];

        unsafe {
            malicious_vec.set_len(20);
        }

        println!("malicious addr: {:?}", malicious_vec.as_mut_ptr());
        println!("trusted   addr: {:?}", trust_vec.as_ptr());

        println!("Before buffer overflow");
        println!("malicious ptr: {:?}", malicious_vec);
        println!("trusted   ptr: {:?}", trust_vec);
        println!("\n");

        // Buffer overflow attack
        malicious_vec[12] = 1;
        malicious_vec[13] = 2;
        malicious_vec[14] = 3;
        malicious_vec[15] = 4;
        malicious_vec[16] = 5;
        malicious_vec[17] = 6;
        malicious_vec[18] = 7;
        malicious_vec[19] = 8;

        println!("After buffer overflow");
        println!("malicious ptr: {:?}", malicious_vec);
        println!("trusted   ptr: {:?}", trust_vec);
        println!("\n");
    }

    #[test]
    #[should_panic]
    fn buffer_overflow_mpk() {
        let mut malicious_vec = vec![0usize; 10];
        let trust_vec = vec![0usize; 10];

        unsafe {
            malicious_vec.set_len(20);
        }

        println!("malicious addr: {:?}", malicious_vec.as_mut_ptr());
        println!("trusted   addr: {:?}", trust_vec.as_ptr());

        println!("Before buffer overflow");
        println!("malicious ptr: {:?}", malicious_vec);
        println!("trusted   ptr: {:?}", trust_vec);
        println!("\n");

        // Buffer overflow attack
        malicious_vec[12] = 1;
        malicious_vec[13] = 2;
        malicious_vec[14] = 3;
        malicious_vec[15] = 4;
        malicious_vec[16] = 5;
        malicious_vec[17] = 6;
        malicious_vec[18] = 7;
        malicious_vec[19] = 8;

        println!("After buffer overflow");
        println!("malicious ptr: {:?}", malicious_vec);
        println!("trusted   ptr: {:?}", trust_vec);
        println!("\n");

        for i in 0..trust_vec.len() {
            assert!(trust_vec[i] == 0);
        }
    }
}

pub unsafe fn pf_handler() {}

pub unsafe fn wrpkru() {}

pub unsafe fn rdpkru() -> u64 {
    let mut eax: u64;
    let ecx: u64 = 0;
    let edx: u64 = 0;

    asm!(
        "rdpkru",
        in("ecx") ecx,
        lateout("eax") eax,
        lateout("edx") _,
    );

    // asm!(
    //     "xor ecx, ecx",
    //     "xor edx, edx",
    //     "rdpkru",
    //     out("eax") out,
    // );
    eax
}

/// Create a new protection key.
pub unsafe fn pkey_alloc(flags: usize, init_val: usize) -> Result<i32, i32> {
    let ret = libc::syscall(libc::SYS_pkey_alloc, flags, init_val);
    if ret < 0 {
        Err(*(libc::__errno_location()))
    } else {
        Ok(ret as i32)
    }
}

/// Free a protection key.
pub unsafe fn pkey_free(pkey: usize) -> Result<(), i32> {
    let ret = libc::syscall(libc::SYS_pkey_free, pkey);
    if ret < 0 {
        Err(*(libc::__errno_location()))
    } else {
        Ok(())
    }
}

/// Set protection on a region of memory.
pub unsafe fn pkey_mprotect(start: usize, len: usize, prot: usize, pkey: usize) -> Result<(), i32> {
    let ret = libc::syscall(libc::SYS_pkey_mprotect, start, len, prot, pkey);
    if ret < 0 {
        Err(*(libc::__errno_location()))
    } else {
        Ok(())
    }
}
